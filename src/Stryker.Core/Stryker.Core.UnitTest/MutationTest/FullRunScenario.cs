using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp;
using Moq;
using Stryker.Core.Initialisation;
using Stryker.Core.Mutants;
using Stryker.Core.TestRunners;

namespace Stryker.Core.UnitTest.MutationTest
{
    /// <summary>
    /// This class simplifies the creation of run scenarios
    /// </summary>
    ///
    internal class FullRunScenario
    {
        // list of mutants
        private readonly Dictionary<int, Mutant> _mutants = new();
        // list of test (and their description)
        private readonly Dictionary<int, TestDescription> _tests = new ();
        // test coverage per mutant
        private readonly Dictionary<int, TestsGuidList> _coverageResult = new();
        // failing tests per mutant
        private readonly Dictionary<int, TestsGuidList> _failedTestsPerMutant = new();
        // fine control: failing tests per mutant, taking into account the other mutants tested in the same session.
        private readonly Dictionary<HashSet<int>, Dictionary<int, TestsGuidList>> _failedTestsPerRun = new(new HashSetComparer());
        private const int InitialRunId = -1;
        private Mock<ITestRunner> _runnerMock;
        /// <summary>
        /// Existing tests.
        /// </summary>
        public TestSet TestSet { get; } = new();
        /// <summary>
        /// Existing mutants.
        /// </summary>
        public IEnumerable<Mutant> Mutants => _mutants.Values;

        /// <summary>
        /// Create a mutant
        /// </summary>
        /// <param name="mutantId">expected mutant Id, autogenerated by default</param>
        /// <returns>A mutant instance</returns>
        public Mutant CreateMutant(int mutantId = -1)
        {
            if (mutantId == -1)
            {
                mutantId = _mutants.Keys.Append(-1).Max() + 1;
            }
            var mutant = BuildMutant(mutantId);
            _mutants[mutantId] = mutant;
            return mutant;
        }

        public static Mutant BuildMutant(int id)
        {
            var mutant = new Mutant
            {
                Id = id,
                Mutation = new Mutation
                {
                    DisplayName = $"Test Mutation {id}.",
                    OriginalNode = SyntaxFactory.ParseStatement("return 1+2;"),
                    ReplacementNode = SyntaxFactory.ParseStatement("return 1-2;")
                }
            };
            return mutant;
        }

        /// <summary>
        /// Create several mutants using provided ids.
        /// </summary>
        /// <param name="mutantIds">list of desired mutants.</param>
        public void CreateMutants(params int[] mutantIds)
        {
            foreach (var id in mutantIds)
            {
                _ = CreateMutant(id);
            }
        }

        /// <summary>
        /// Get the list of mutants that must be tested.
        /// </summary>
        /// <returns></returns>
        public IEnumerable<Mutant> GetTestableMutants() => _coverageResult.Keys.Select(i => _mutants[i]);

        /// <summary>
        /// Get the status of the mutant of a given id
        /// </summary>
        /// <param name="mutantId">requested mutant id</param>
        /// <returns>return the mutant's status</returns>
        public MutantStatus GetMutantStatus(int mutantId) => _mutants[mutantId].ResultStatus;
        /// <summary>
        /// Declare the tests covering one mutant
        /// </summary>
        /// <param name="mutantId">mutant id</param>
        /// <param name="testIds">tests covering the given mutant</param>
        public void DeclareCoverageForMutant(int mutantId, params int[] testIds) => _coverageResult[mutantId] = GetGuidList(testIds);
        /// <summary>
        /// Declare that the mutant must be run against all tests.
        /// </summary>
        /// <param name="mutantId">mutant id</param>
        public void DeclareFullCoverageForMutant(int mutantId) => _coverageResult[mutantId] = GetGuidList();
        /// <summary>
        /// Declare tests that are failing against the non mutated assembly.
        /// </summary>
        /// <param name="testIds">test ids</param>
        public void DeclareTestsFailingAtInit(params int[] testIds) => DeclareTestsFailingWhenTestingMutant(InitialRunId, testIds);
        /// <summary>
        /// Declare the tests that are failing when testing a mutant.
        /// </summary>
        /// <param name="mutantId">Mutant id</param>
        /// <param name="testIds">Test(s) failing for this mutant</param>
        public void DeclareTestsFailingWhenTestingMutant(int mutantId, params int[] testIds)
        {
            var testsGuidList = GetGuidList(testIds);
            if (!testsGuidList.IsIncluded(GetCoveringTests(mutantId)))
            {
                // just check we are not doing something stupid
                throw new ApplicationException(
                    $"you tried to declare a failing test but it does not cover mutant {mutantId}");
            }
            _failedTestsPerMutant[mutantId] = testsGuidList;
        }

        /// <summary>
        /// Declare tests that fail for a specific run
        /// </summary>
        /// <param name="mutantIds">list of mutants for the run</param>
        /// <param name="mutantId">mutant concerned by those tests</param>
        /// <param name="testIds">tests that fail</param>
        public void DeclareTestsFailingWhenTestingMutant(IEnumerable<int> mutantIds,int mutantId, params int[] testIds)
        {
            var key = mutantIds.ToHashSet();
            var testsGuidList = GetGuidList(testIds);

            if (!_failedTestsPerRun.ContainsKey(key))
            {
                _failedTestsPerRun[key] = new Dictionary<int, TestsGuidList>();
            }
            _failedTestsPerRun[key][mutantId] = testsGuidList;
        }

        /// <summary>
        /// Create a test
        /// </summary>
        /// <param name="testId"></param>
        /// <param name="name"></param>
        /// <param name="file"></param>
        /// <returns></returns>
        public TestDescription CreateTest(int testId = -1, string name = null, string file = "TestFile.cs")
        {
            if (testId == -1)
            {
                testId = _tests.Keys.Append(-1).Max()+1;
            }

            var test = new TestDescription(Guid.NewGuid(), name ?? $"test {testId}", file);
            _tests[testId] = test;
            TestSet.RegisterTests(new[] { test });
            return test;
        }

        /// <summary>
        /// Create tests.
        /// </summary>
        /// <param name="testIds">List of ids to create test out of.</param>
        public void CreateTests(params int[] testIds)
        {
            foreach (var id in testIds)
            {
                CreateTest(id);
            }
        }

        /// <summary>
        /// Returns a list of test Guids
        /// </summary>
        /// <param name="testIds"></param>
        /// <returns></returns>
        public TestsGuidList GetGuidList(params int[] testIds) => new TestsGuidList(testIds.Select(i => _tests[i]).Select(t => t.Id));

        private TestsGuidList GetGuidList() => new(_tests.Values.Select(t => t.Id));

        private TestsGuidList GetFailedTests(int mutantId, IEnumerable<int> readOnlyList)
        {
            if (readOnlyList != null)
            {
                var mutantIds = readOnlyList.ToHashSet();
                if (_failedTestsPerRun.ContainsKey(mutantIds))
                {
                    if (_failedTestsPerRun[mutantIds].TryGetValue(mutantId, out var list1))
                    {
                        return list1;
                    }
                }
            }

            if (_failedTestsPerMutant.TryGetValue(mutantId, out var list))
            {
                return list;
            }
            return TestsGuidList.NoTest();
        }

        private TestsGuidList GetCoveringTests(int mutantId)
        {
            if (_coverageResult.TryGetValue(mutantId, out var list))
            {
                if (list.Count == TestSet.Count)
                {
                    return TestsGuidList.EveryTest();
                }
                return list;
            }

            // if this is the initial test run, we must return the complete list of tests.
            return mutantId == InitialRunId ? new TestsGuidList(_tests.Values.Select(t => t.Id)) : TestsGuidList.NoTest();
        }

        private TestRunResult GetRunResult(int id) => new(GetCoveringTests(id), GetFailedTests(id, null), TestsGuidList.NoTest(), string.Empty, TimeSpan.Zero);

        public TestRunResult GetInitialRunResult() => GetRunResult(InitialRunId);

        public Mock<ITestRunner> GetTestRunnerMock()
        {
            if (_runnerMock != null)
            {
                return _runnerMock;
            }

            _runnerMock = new Mock<ITestRunner>();
            var successResult = new TestRunResult(GetGuidList(),
                TestsGuidList.NoTest(),
                TestsGuidList.NoTest(),
                string.Empty,
                TimeSpan.Zero);
            _runnerMock.Setup(x => x.DiscoverTests()).Returns(TestSet);
            _runnerMock.Setup(x => x.InitialTest()).Returns(GetRunResult(InitialRunId));
            _runnerMock.Setup(x => x.CaptureCoverage(It.IsAny<IEnumerable<Mutant>>()))
                .Callback((Action<IEnumerable<Mutant>>)(t =>
                {
                    foreach (var m in t)
                    {
                        m.CoveringTests = GetCoveringTests(m.Id);
                        if (m.CoveringTests.Count == TestSet.Count)
                        {
                            m.CoveringTests = TestsGuidList.EveryTest();
                        }
                    }
                })).Returns(successResult);
            _runnerMock.Setup(x => x.TestMultipleMutants(It.IsAny<ITimeoutValueCalculator>(),
                    It.IsAny<IReadOnlyList<Mutant>>(), It.IsAny<TestUpdateHandler>())).
                Callback((Action<ITimeoutValueCalculator, IReadOnlyList<Mutant>, TestUpdateHandler>)((test1, list,
                    update) =>
                {
                    var ids = list.Select(m => m.Id);
                    foreach (var m in list)
                    {
                        update(list, GetFailedTests(m.Id, ids), GetCoveringTests(m.Id), TestsGuidList.NoTest());
                    }
                }))
                .Returns(successResult);
            return _runnerMock;
        }


        private class HashSetComparer : IEqualityComparer<HashSet<int>>
        {
            public bool Equals(HashSet<int> x, HashSet<int> y) => x!= null && y!= null && x.SetEquals(y);

            public int GetHashCode([DisallowNull] HashSet<int> obj) => obj.Aggregate(0, (current, entry) => current ^ entry.GetHashCode());
        }
    }
}
